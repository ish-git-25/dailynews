import { useState, useEffect, useRef } from 'react'

// Placeholder for Word document content
// Replace this array with the actual content from your Word document
// Each string in the array will become a paragraph
const articleContent = [
  "OS LAB",
  "3_Write a program to compute the finish time, turnaround time and waiting time for the following algorithms:",
  "a) First come First serve",
  "b) Shortest Job First (Preemptive and Non-Preemptive)",
  "c) Priority (Preemptive and Non-Preemptive)",
  "d) Round robin",
  "Code:",
  "#include <iostream>\n\n#include <algorithm>\n\n#include <queue>\n\n#include <vector>\n\nusing namespace std;\n\n\n\nstruct Process {\n    int pid, at, bt, rt, pr, ft, tat, wt;\n    bool done = false;\n};\n\n\n\n// =================== FCFS ===================\n\nvoid FCFS(vector<Process> p, int n) {\n    sort(p.begin(), p.end(), [](Process a, Process b){ return a.at < b.at; });\n\n\n    p[0].ft = p[0].at + p[0].bt;\n    p[0].tat = p[0].ft - p[0].at;\n    p[0].wt = p[0].tat - p[0].bt;\n\n\n    for (int i = 1; i < n; i++) {\n        if (p[i].at > p[i - 1].ft)\n            p[i].ft = p[i].at + p[i].bt;\n        else\n            p[i].ft = p[i - 1].ft + p[i].bt;\n\n\n        p[i].tat = p[i].ft - p[i].at;\n        p[i].wt = p[i].tat - p[i].bt;\n    }\n\n\n    cout << \"\\nFCFS Scheduling:\\nPID\\tAT\\tBT\\tFT\\tTAT\\tWT\\n\";\n    for (auto &x : p)\n        cout << x.pid << \"\\t\" << x.at << \"\\t\" << x.bt << \"\\t\"\n             << x.ft << \"\\t\" << x.tat << \"\\t\" << x.wt << \"\\n\";\n}\n\n\n\n// =================== SJF Non-Preemptive ===================\n\nvoid SJF_NP(vector<Process> p, int n) {\n    int t = 0, completed = 0;\n    while (completed < n) {\n        int idx = -1, mn = 1e9;\n        for (int i = 0; i < n; i++) {\n            if (!p[i].done && p[i].at <= t && p[i].bt < mn) {\n                mn = p[i].bt;\n                idx = i;\n            }\n        }\n        if (idx == -1) { t++; continue; }\n        t += p[idx].bt;\n        p[idx].ft = t;\n        p[idx].tat = p[idx].ft - p[idx].at;\n        p[idx].wt = p[idx].tat - p[idx].bt;\n        p[idx].done = true;\n        completed++;\n    }\n\n\n    cout << \"\\nSJF Non-Preemptive:\\nPID\\tAT\\tBT\\tFT\\tTAT\\tWT\\n\";\n    for (auto &x : p)\n        cout << x.pid << \"\\t\" << x.at << \"\\t\" << x.bt << \"\\t\"\n             << x.ft << \"\\t\" << x.tat << \"\\t\" << x.wt << \"\\n\";\n}\n\n\n\n// =================== SJF Preemptive (SRTF) ===================\n\nvoid SJF_P(vector<Process> p, int n) {\n    for (int i = 0; i < n; i++) p[i].rt = p[i].bt;\n    int t = 0, completed = 0;\n\n\n    while (completed < n) {\n        int idx = -1, mn = 1e9;\n        for (int i = 0; i < n; i++) {\n            if (p[i].at <= t && p[i].rt > 0 && p[i].rt < mn) {\n                mn = p[i].rt;\n                idx = i;\n            }\n        }\n        if (idx == -1) { t++; continue; }\n        p[idx].rt--; t++;\n        if (p[idx].rt == 0) {\n            p[idx].ft = t;\n            p[idx].tat = p[idx].ft - p[idx].at;\n            p[idx].wt = p[idx].tat - p[idx].bt;\n            completed++;\n        }\n    }\n\n\n    cout << \"\\nSJF Preemptive (SRTF):\\nPID\\tAT\\tBT\\tFT\\tTAT\\tWT\\n\";\n    for (auto &x : p)\n        cout << x.pid << \"\\t\" << x.at << \"\\t\" << x.bt << \"\\t\"\n             << x.ft << \"\\t\" << x.tat << \"\\t\" << x.wt << \"\\n\";\n}\n\n\n\n// =================== Priority Non-Preemptive ===================\n\nvoid Priority_NP(vector<Process> p, int n) {\n    int t = 0, completed = 0;\n    while (completed < n) {\n        int idx = -1, best = 1e9;\n        for (int i = 0; i < n; i++) {\n            if (!p[i].done && p[i].at <= t && p[i].pr < best) {\n                best = p[i].pr;\n                idx = i;\n            }\n        }\n        if (idx == -1) { t++; continue; }\n        t += p[idx].bt;\n        p[idx].ft = t;\n        p[idx].tat = p[idx].ft - p[idx].at;\n        p[idx].wt = p[idx].tat - p[idx].bt;\n        p[idx].done = true;\n        completed++;\n    }\n\n\n    cout << \"\\nPriority Non-Preemptive:\\nPID\\tAT\\tBT\\tPR\\tFT\\tTAT\\tWT\\n\";\n    for (auto &x : p)\n        cout << x.pid << \"\\t\" << x.at << \"\\t\" << x.bt << \"\\t\" << x.pr << \"\\t\"\n             << x.ft << \"\\t\" << x.tat << \"\\t\" << x.wt << \"\\n\";\n}\n\n\n\n// =================== Priority Preemptive ===================\n\nvoid Priority_P(vector<Process> p, int n) {\n    for (int i = 0; i < n; i++) p[i].rt = p[i].bt;\n    int t = 0, completed = 0;\n\n\n    while (completed < n) {\n        int idx = -1, best = 1e9;\n        for (int i = 0; i < n; i++) {\n            if (p[i].at <= t && p[i].rt > 0 && p[i].pr < best) {\n                best = p[i].pr;\n                idx = i;\n            }\n        }\n        if (idx == -1) { t++; continue; }\n        p[idx].rt--; t++;\n        if (p[idx].rt == 0) {\n            p[idx].ft = t;\n            p[idx].tat = p[idx].ft - p[idx].at;\n            p[idx].wt = p[idx].tat - p[idx].bt;\n            completed++;\n        }\n    }\n\n\n    cout << \"\\nPriority Preemptive:\\nPID\\tAT\\tBT\\tPR\\tFT\\tTAT\\tWT\\n\";\n    for (auto &x : p)\n        cout << x.pid << \"\\t\" << x.at << \"\\t\" << x.bt << \"\\t\" << x.pr << \"\\t\"\n             << x.ft << \"\\t\" << x.tat << \"\\t\" << x.wt << \"\\n\";\n}\n\n\n\n// =================== Round Robin ===================\n\nvoid RoundRobin(vector<Process> p, int n, int tq) {\n    for (int i = 0; i < n; i++) p[i].rt = p[i].bt;\n    queue<int> q;\n    vector<bool> inQueue(n, false);\n    int t = 0, completed = 0;\n\n\n    while (completed < n) {\n        for (int i = 0; i < n; i++)\n            if (!inQueue[i] && p[i].at <= t && p[i].rt > 0) {\n                q.push(i); inQueue[i] = true;\n            }\n\n\n        if (q.empty()) { t++; continue; }\n\n\n        int idx = q.front(); q.pop();\n        int exec = min(tq, p[idx].rt);\n        p[idx].rt -= exec;\n        t += exec;\n\n\n        for (int i = 0; i < n; i++)\n            if (!inQueue[i] && p[i].at <= t && p[i].rt > 0) {\n                q.push(i); inQueue[i] = true;\n            }\n\n\n        if (p[idx].rt > 0)\n            q.push(idx);\n        else {\n            p[idx].ft = t;\n            p[idx].tat = p[idx].ft - p[idx].at;\n            p[idx].wt = p[idx].tat - p[idx].bt;\n            completed++;\n        }\n    }\n\n\n    cout << \"\\nRound Robin:\\nPID\\tAT\\tBT\\tFT\\tTAT\\tWT\\n\";\n    for (auto &x : p)\n        cout << x.pid << \"\\t\" << x.at << \"\\t\" << x.bt << \"\\t\"\n             << x.ft << \"\\t\" << x.tat << \"\\t\" << x.wt << \"\\n\";\n}\n\n\n\n// =================== MAIN MENU ===================\n\nint main() {\n    int n, choice, tq;\n    cout << \"Enter number of processes: \";\n    cin >> n;\n    vector<Process> p(n);\n\n\n    for (int i = 0; i < n; i++) {\n        p[i].pid = i + 1;\n        cout << \"Enter Arrival Time and Burst Time for P\" << p[i].pid << \": \";\n        cin >> p[i].at >> p[i].bt;\n        cout << \"Enter Priority for P\" << p[i].pid << \": \";\n        cin >> p[i].pr;\n    }\n\n\n    cout << \"\\nChoose Scheduling Algorithm:\\n\";\n    cout << \"1. FCFS\\n\";\n    cout << \"2. SJF Non-Preemptive\\n\";\n    cout << \"3. SJF Preemptive (SRTF)\\n\";\n    cout << \"4. Priority Non-Preemptive\\n\";\n    cout << \"5. Priority Preemptive\\n\";\n    cout << \"6. Round Robin\\n\";\n    cout << \"Enter choice: \";\n    cin >> choice;\n\n\n    switch (choice) {\n        case 1: FCFS(p, n); break;\n        case 2: SJF_NP(p, n); break;\n        case 3: SJF_P(p, n); break;\n        case 4: Priority_NP(p, n); break;\n        case 5: Priority_P(p, n); break;\n        case 6: cout << \"Enter Time Quantum: \"; cin >> tq;\n                RoundRobin(p, n, tq); break;\n        default: cout << \"Invalid Choice!\\n\";\n    }\n    return 0;\n}\n",
  "4_Write a program to check whether given system is in safe state or not using Banker’s Deadlock Avoidance algorithm.",
  "#include <iostream>\n\n#include <vector>\n\n\nint main() {\n    int n, m; // n = number of processes, m = number of resource types\n\n\n    std::cout << \"Enter number of processes: \";\n    std::cin >> n;\n\n\n    std::cout << \"Enter number of resource types: \";\n    std::cin >> m;\n\n\n    std::vector<std::vector<int>> alloc(n, std::vector<int>(m));\n    std::vector<std::vector<int>> maxm(n, std::vector<int>(m));\n    std::vector<std::vector<int>> need(n, std::vector<int>(m));\n    std::vector<int> avail(m);\n    std::vector<int> finish(n, 0);\n    std::vector<int> safeSeq(n);\n\n\n    // Input Allocation Matrix\n    std::cout << \"Enter Allocation Matrix (\" << n << \" x \" << m << \"):\\n\";\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            std::cin >> alloc[i][j];\n        }\n    }\n\n\n    // Input Max Matrix\n    std::cout << \"Enter Max Matrix (\" << n << \" x \" << m << \"):\\n\";\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            std::cin >> maxm[i][j];\n        }\n    }\n\n\n    // Input Available resources\n    std::cout << \"Enter Available resources (\" << m << \" values):\\n\";\n    for (int j = 0; j < m; j++) {\n        std::cin >> avail[j];\n    }\n\n\n    // Calculate Need matrix: need = max - alloc\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            need[i][j] = maxm[i][j] - alloc[i][j];\n        }\n    }\n\n\n    int count = 0; // number of processes in safe sequence\n\n\n    // Safety Algorithm\n    while (count < n) {\n        bool found = false;\n\n\n        for (int i = 0; i < n; i++) {\n            if (finish[i] == 0) {\n                bool canAllocate = true;\n\n\n                // Check if need[i] <= avail for all resources\n                for (int j = 0; j < m; j++) {\n                    if (need[i][j] > avail[j]) {\n                        canAllocate = false;\n                        break;\n                    }\n                }\n\n\n                // If process i can be allocated\n                if (canAllocate) {\n                    for (int k = 0; k < m; k++) {\n                        avail[k] += alloc[i][k];\n                    }\n\n\n                    safeSeq[count++] = i;\n                    finish[i] = 1;\n                    found = true;\n                }\n            }\n        }\n\n\n        // If no process could be allocated in this pass, system is not safe\n        if (!found) {\n            std::cout << \"\\nSystem is NOT in a safe state (Deadlock possible).\\n\";\n            return 0;\n        }\n    }\n\n\n    // If all processes are finished, system is safe\n    std::cout << \"\\nSystem is in a SAFE state.\\nSafe sequence: \";\n    for (int i = 0; i < n; i++) {\n        std::cout << \"P\" << safeSeq[i] << \" \";\n    }\n    std::cout << \"\\n\";\n\n\n    return 0;\n}\n",
  "5_Implementation of Classical problems using Threads and Mutex.",
  "#include <iostream>\n\n#include <thread>\n\n#include <mutex>\n\n#include <condition_variable>\n\n#include <vector>\n\n#include <chrono>\n\n#include <atomic>\n\n\n/* ---------- PRODUCER–CONSUMER (BOUNDED BUFFER) ---------- */\n\n\n#define BUFFER_SIZE 5\n\n#define PC_ITERATIONS 5\n\n\nint buffer_pc[BUFFER_SIZE];\nint count_pc = 0;\nint in_pc = 0, out_pc = 0;\n\n\nstd::mutex pc_mutex;\nstd::condition_variable pc_not_full;\nstd::condition_variable pc_not_empty;\n\n\nvoid producer() {\n    int item = 1;\n    for (int i = 0; i < PC_ITERATIONS; i++) {\n        std::unique_lock<std::mutex> lock(pc_mutex);\n\n\n        pc_not_full.wait(lock, [] { return count_pc < BUFFER_SIZE; });\n\n\n        buffer_pc[in_pc] = item;\n        std::cout << \"[Producer] produced: \" << item << \"\\n\";\n        in_pc = (in_pc + 1) % BUFFER_SIZE;\n        count_pc++;\n        item++;\n\n\n        pc_not_empty.notify_one();\n        lock.unlock();\n\n\n        std::this_thread::sleep_for(std::chrono::seconds(1));\n    }\n}\n\n\nvoid consumer() {\n    for (int i = 0; i < PC_ITERATIONS; i++) {\n        std::unique_lock<std::mutex> lock(pc_mutex);\n\n\n        pc_not_empty.wait(lock, [] { return count_pc > 0; });\n\n\n        int item = buffer_pc[out_pc];\n        std::cout << \"[Consumer] consumed: \" << item << \"\\n\";\n        out_pc = (out_pc + 1) % BUFFER_SIZE;\n        count_pc--;\n\n\n        pc_not_full.notify_one();\n        lock.unlock();\n\n\n        std::this_thread::sleep_for(std::chrono::seconds(1));\n    }\n}\n\n\nvoid run_producer_consumer() {\n    count_pc = 0;\n    in_pc = out_pc = 0;\n\n\n    std::cout << \"\\n--- Producer–Consumer Simulation ---\\n\";\n\n\n    std::thread prod(producer);\n    std::thread cons(consumer);\n\n\n    prod.join();\n    cons.join();\n\n\n    std::cout << \"--- Producer–Consumer Finished ---\\n\\n\";\n}\n\n\n/* ---------- DINING PHILOSOPHERS ---------- */\n\n\n#define NPHIL 5\n\n#define EAT_TIMES 3\n\n\nstd::mutex forks[NPHIL];\n\n\nvoid philosopher(int id) {\n    for (int i = 0; i < EAT_TIMES; i++) {\n        std::cout << \"Philosopher \" << id << \" is thinking\\n\";\n        std::this_thread::sleep_for(std::chrono::seconds(1));\n\n\n        if (id == NPHIL - 1) {\n            // Last philosopher picks up right then left to avoid deadlock\n            forks[(id + 1) % NPHIL].lock();\n            forks[id].lock();\n        } else {\n            forks[id].lock();\n            forks[(id + 1) % NPHIL].lock();\n        }\n\n\n        std::cout << \"Philosopher \" << id << \" is eating\\n\";\n        std::this_thread::sleep_for(std::chrono::seconds(1));\n\n\n        forks[id].unlock();\n        forks[(id + 1) % NPHIL].unlock();\n    }\n    std::cout << \"Philosopher \" << id << \" is done.\\n\";\n}\n\n\nvoid run_dining_philosophers() {\n    std::cout << \"\\n--- Dining Philosophers Simulation ---\\n\";\n\n\n    std::vector<std::thread> threads;\n\n\n    for (int i = 0; i < NPHIL; i++) {\n        threads.emplace_back(philosopher, i);\n    }\n\n\n    for (auto& t : threads) {\n        t.join();\n    }\n\n\n    std::cout << \"--- Dining Philosophers Finished ---\\n\\n\";\n}\n\n\n/* ---------- READERS–WRITERS (FIRST PROBLEM) ---------- */\n\n\nint read_count = 0;\nint shared_data = 0;\n\n\nstd::mutex rw_mutex;        // for protecting read_count\nstd::mutex rw_write_lock;   // for writers (and first/last reader)\n\n\n#define READERS 3\n\n#define WRITERS 2\n\n#define RW_ITER 3\n\n\nvoid reader(int id) {\n    for (int i = 0; i < RW_ITER; i++) {\n        // Entry section\n        {\n            std::lock_guard<std::mutex> lock(rw_mutex);\n            read_count++;\n            if (read_count == 1) {\n                rw_write_lock.lock();\n            }\n        }\n\n\n        // Critical section\n        std::cout << \"[Reader \" << id << \"] reads data = \" << shared_data << \"\\n\";\n        std::this_thread::sleep_for(std::chrono::seconds(1));\n\n\n        // Exit section\n        {\n            std::lock_guard<std::mutex> lock(rw_mutex);\n            read_count--;\n            if (read_count == 0) {\n                rw_write_lock.unlock();\n            }\n        }\n\n\n        std::this_thread::sleep_for(std::chrono::seconds(1));\n    }\n}\n\n\nvoid writer(int id) {\n    for (int i = 0; i < RW_ITER; i++) {\n        rw_write_lock.lock();\n\n\n        shared_data++;\n        std::cout << \"[Writer \" << id << \"] writes data = \" << shared_data << \"\\n\";\n        std::this_thread::sleep_for(std::chrono::seconds(1));\n\n\n        rw_write_lock.unlock();\n\n\n        std::this_thread::sleep_for(std::chrono::seconds(2));\n    }\n}\n\n\nvoid run_readers_writers() {\n    std::cout << \"\\n--- Readers–Writers Simulation ---\\n\";\n\n\n    read_count = 0;\n    shared_data = 0;\n\n\n    std::vector<std::thread> rthreads;\n    std::vector<std::thread> wthreads;\n\n\n    for (int i = 0; i < READERS; i++) {\n        rthreads.emplace_back(reader, i + 1);\n    }\n\n\n    for (int i = 0; i < WRITERS; i++) {\n        wthreads.emplace_back(writer, i + 1);\n    }\n\n\n    for (auto& t : rthreads) {\n        t.join();\n    }\n    for (auto& t : wthreads) {\n        t.join();\n    }\n\n\n    std::cout << \"--- Readers–Writers Finished ---\\n\\n\";\n}\n\n\n/* ---------- MAIN MENU ---------- */\n\n\nint main() {\n    int choice;\n\n\n    while (true) {\n        std::cout << \"==== Classical Problems using C++ Threads & Mutex ====\\n\";\n        std::cout << \"1. Producer–Consumer Problem\\n\";\n        std::cout << \"2. Dining Philosophers Problem\\n\";\n        std::cout << \"3. Readers–Writers Problem\\n\";\n        std::cout << \"4. Exit\\n\";\n        std::cout << \"Enter your choice: \";\n\n\n        if (!(std::cin >> choice)) {\n            std::cout << \"Invalid input. Exiting.\\n\";\n            break;\n        }\n\n\n        switch (choice) {\n            case 1:\n                run_producer_consumer();\n                break;\n            case 2:\n                run_dining_philosophers();\n                break;\n            case 3:\n                run_readers_writers();\n                break;\n            case 4:\n                std::cout << \"Exiting...\\n\";\n                return 0;\n            default:\n                std::cout << \"Invalid choice. Try again.\\n\\n\";\n        }\n    }\n\n\n    return 0;\n}\n",
  "6_Implementation of Classical problems using Threads and Semaphore.",
  "#include <iostream>\n\n#include <cstdlib>\n\n#include <pthread.h>\n\n#include <unistd.h>\n\n#include <semaphore.h>\n\n\n/* ========== 1. PRODUCER–CONSUMER USING SEMAPHORES ========== */\n\n\n#define BUFFER_SIZE 5\n\n#define PC_ITERATIONS 5\n\n\nint buffer[BUFFER_SIZE];\nint in_pc = 0, out_pc = 0;\n\n\nsem_t empty;      // counts empty slots\nsem_t full;       // counts full slots\nsem_t pc_mutex;   // binary semaphore for mutual exclusion\n\n\nvoid* producer_sema(void* arg) {\n    int item = 1;\n    for (int i = 0; i < PC_ITERATIONS; i++) {\n        sem_wait(&empty);         // wait for empty slot\n        sem_wait(&pc_mutex);      // lock buffer\n\n\n        buffer[in_pc] = item;\n        std::cout << \"[Producer] produced: \" << item << std::endl;\n        in_pc = (in_pc + 1) % BUFFER_SIZE;\n        item++;\n\n\n        sem_post(&pc_mutex);      // unlock buffer\n        sem_post(&full);          // signal item available\n\n\n        sleep(1);\n    }\n    return nullptr;\n}\n\n\nvoid* consumer_sema(void* arg) {\n    for (int i = 0; i < PC_ITERATIONS; i++) {\n        sem_wait(&full);          // wait for available item\n        sem_wait(&pc_mutex);      // lock buffer\n\n\n        int item = buffer[out_pc];\n        std::cout << \"[Consumer] consumed: \" << item << std::endl;\n        out_pc = (out_pc + 1) % BUFFER_SIZE;\n\n\n        sem_post(&pc_mutex);      // unlock buffer\n        sem_post(&empty);         // signal empty slot\n\n\n        sleep(1);\n    }\n    return nullptr;\n}\n\n\nvoid run_producer_consumer_sema() {\n    pthread_t prod, cons;\n\n\n    in_pc = out_pc = 0;\n\n\n    sem_init(&empty, 0, BUFFER_SIZE);\n    sem_init(&full, 0, 0);\n    sem_init(&pc_mutex, 0, 1);\n\n\n    std::cout << \"\\n--- Producer–Consumer using Semaphores ---\" << std::endl;\n\n\n    pthread_create(&prod, nullptr, producer_sema, nullptr);\n    pthread_create(&cons, nullptr, consumer_sema, nullptr);\n\n\n    pthread_join(prod, nullptr);\n    pthread_join(cons, nullptr);\n\n\n    sem_destroy(&empty);\n    sem_destroy(&full);\n    sem_destroy(&pc_mutex);\n\n\n    std::cout << \"--- Producer–Consumer Finished ---\\n\" << std::endl;\n}\n\n\n/* ========== 2. DINING PHILOSOPHERS USING SEMAPHORES ========== */\n\n\n#define NPHIL 5\n\n#define EAT_TIMES 3\n\n\nsem_t forks_sema[NPHIL];\n\n\nvoid* philosopher_sema(void* arg) {\n    int id = *static_cast<int*>(arg);\n\n\n    for (int i = 0; i < EAT_TIMES; i++) {\n        std::cout << \"Philosopher \" << id << \" is thinking\" << std::endl;\n        sleep(1);\n\n\n        int left = id;\n        int right = (id + 1) % NPHIL;\n\n\n        // To reduce deadlock chance, let last philosopher pick right first\n        if (id == NPHIL - 1) {\n            sem_wait(&forks_sema[right]);\n            sem_wait(&forks_sema[left]);\n        } else {\n            sem_wait(&forks_sema[left]);\n            sem_wait(&forks_sema[right]);\n        }\n\n\n        std::cout << \"Philosopher \" << id << \" is eating\" << std::endl;\n        sleep(1);\n\n\n        sem_post(&forks_sema[left]);\n        sem_post(&forks_sema[right]);\n    }\n    std::cout << \"Philosopher \" << id << \" is done.\" << std::endl;\n    return nullptr;\n}\n\n\nvoid run_dining_philosophers_sema() {\n    pthread_t tid[NPHIL];\n    int ids[NPHIL];\n\n\n    std::cout << \"\\n--- Dining Philosophers using Semaphores ---\" << std::endl;\n\n\n    for (int i = 0; i < NPHIL; i++) {\n        sem_init(&forks_sema[i], 0, 1); // each fork available (1)\n    }\n\n\n    for (int i = 0; i < NPHIL; i++) {\n        ids[i] = i;\n        pthread_create(&tid[i], nullptr, philosopher_sema, &ids[i]);\n    }\n\n\n    for (int i = 0; i < NPHIL; i++) {\n        pthread_join(tid[i], nullptr);\n    }\n\n\n    for (int i = 0; i < NPHIL; i++) {\n        sem_destroy(&forks_sema[i]);\n    }\n\n\n    std::cout << \"--- Dining Philosophers Finished ---\\n\" << std::endl;\n}\n\n\n/* ========== 3. READERS–WRITERS USING SEMAPHORES (1st problem) ========== */\n\n\nint read_count = 0;\nint shared_data = 0;\n\n\nsem_t rw_mutex;     // protects read_count\nsem_t rw_wrt;       // ensures mutual exclusion for writers\n\n\n#define READERS 3\n\n#define WRITERS 2\n\n#define RW_ITER 3\n\n\nvoid* reader_sema(void* arg) {\n    int id = *static_cast<int*>(arg);\n\n\n    for (int i = 0; i < RW_ITER; i++) {\n        sem_wait(&rw_mutex);\n        read_count++;\n        if (read_count == 1) {\n            sem_wait(&rw_wrt);    // first reader locks writers\n        }\n        sem_post(&rw_mutex);\n\n\n        std::cout << \"[Reader \" << id << \"] reads data = \" << shared_data << std::endl;\n        sleep(1);\n\n\n        sem_wait(&rw_mutex);\n        read_count--;\n        if (read_count == 0) {\n            sem_post(&rw_wrt);    // last reader unlocks writers\n        }\n        sem_post(&rw_mutex);\n\n\n        sleep(1);\n    }\n    return nullptr;\n}\n\n\nvoid* writer_sema(void* arg) {\n    int id = *static_cast<int*>(arg);\n\n\n    for (int i = 0; i < RW_ITER; i++) {\n        sem_wait(&rw_wrt);\n\n\n        shared_data++;\n        std::cout << \"[Writer \" << id << \"] writes data = \" << shared_data << std::endl;\n        sleep(1);\n\n\n        sem_post(&rw_wrt);\n\n\n        sleep(2);\n    }\n    return nullptr;\n}\n\n\nvoid run_readers_writers_sema() {\n    pthread_t rtid[READERS], wtid[WRITERS];\n    int rids[READERS], wids[WRITERS];\n\n\n    read_count = 0;\n    shared_data = 0;\n\n\n    sem_init(&rw_mutex, 0, 1);\n    sem_init(&rw_wrt, 0, 1);\n\n\n    std::cout << \"\\n--- Readers–Writers using Semaphores ---\" << std::endl;\n\n\n    for (int i = 0; i < READERS; i++) {\n        rids[i] = i + 1;\n        pthread_create(&rtid[i], nullptr, reader_sema, &rids[i]);\n    }\n\n\n    for (int i = 0; i < WRITERS; i++) {\n        wids[i] = i + 1;\n        pthread_create(&wtid[i], nullptr, writer_sema, &wids[i]);\n    }\n\n\n    for (int i = 0; i < READERS; i++) {\n        pthread_join(rtid[i], nullptr);\n    }\n    for (int i = 0; i < WRITERS; i++) {\n        pthread_join(wtid[i], nullptr);\n    }\n\n\n    sem_destroy(&rw_mutex);\n    sem_destroy(&rw_wrt);\n\n\n    std::cout << \"--- Readers–Writers Finished ---\\n\" << std::endl;\n}\n\n\n/* ========== MAIN MENU ========== */\n\n\nint main() {\n    int choice;\n\n\n    while (true) {\n        std::cout << \"==== Classical Problems using Threads & Semaphores ====\\n\";\n        std::cout << \"1. Producer–Consumer Problem\\n\";\n        std::cout << \"2. Dining Philosophers Problem\\n\";\n        std::cout << \"3. Readers–Writers Problem\\n\";\n        std::cout << \"4. Exit\\n\";\n        std::cout << \"Enter your choice: \";\n\n\n        if (!(std::cin >> choice)) {\n            std::cout << \"Invalid input. Exiting.\\n\";\n            break;\n        }\n\n\n        switch (choice) {\n            case 1:\n                run_producer_consumer_sema();\n                break;\n            case 2:\n                run_dining_philosophers_sema();\n                break;\n            case 3:\n                run_readers_writers_sema();\n                break;\n            case 4:\n                std::cout << \"Exiting...\\n\";\n                return 0;\n            default:\n                std::cout << \"Invalid choice. Try again.\\n\\n\";\n        }\n    }\n\n\n    return 0;\n}\n",
  "7_Write a program to calculate the number of page faults for a reference string for the following page replacement algorithms: a) FIFO b) LRU c) Optimal",
  "Code:",
  "#include <bits/stdc++.h>\n\nusing namespace std;\n\n\nint fifoPageFaults(vector<int>& refs, int frames) {\n    queue<int> q;\n    unordered_set<int> s;\n    int faults = 0;\n\n\n    for (int p : refs) {\n        if (s.find(p) == s.end()) {\n            faults++;\n            if (q.size() == frames) {\n                int old = q.front(); q.pop();\n                s.erase(old);\n            }\n            q.push(p);\n            s.insert(p);\n        }\n    }\n    return faults;\n}\n\n\nint lruPageFaults(vector<int>& refs, int frames) {\n    list<int> recent;\n    unordered_map<int, list<int>::iterator> mp;\n    int faults = 0;\n\n\n    for (int p : refs) {\n        if (mp.find(p) == mp.end()) {\n            faults++;\n            if (recent.size() == frames) {\n                int lru = recent.front();\n                recent.pop_front();\n                mp.erase(lru);\n            }\n            recent.push_back(p);\n            mp[p] = --recent.end();\n        } else {\n            recent.erase(mp[p]);\n            recent.push_back(p);\n            mp[p] = --recent.end();\n        }\n    }\n    return faults;\n}\n\n\nint optimalPageFaults(vector<int>& refs, int frames) {\n    vector<int> fr;\n    int faults = 0;\n    int n = refs.size();\n\n\n    for (int i = 0; i < n; i++) {\n        int p = refs[i];\n        bool hit = false;\n\n\n        for (int x : fr)\n            if (x == p) hit = true;\n\n\n        if (hit) continue;\n\n\n        faults++;\n\n\n        if (fr.size() < frames) {\n            fr.push_back(p);\n            continue;\n        }\n\n\n        int idx = -1, farthest = -1;\n\n\n        for (int j = 0; j < fr.size(); j++) {\n            int page = fr[j];\n            int k;\n            for (k = i + 1; k < n; k++)\n                if (refs[k] == page) break;\n\n\n            if (k == n) {\n                idx = j;\n                break;\n            }\n\n\n            if (k > farthest) {\n                farthest = k;\n                idx = j;\n            }\n        }\n\n\n        fr[idx] = p;\n    }\n    return faults;\n}\n\n\nint main() {\n    int frames, n;\n\n\n    cout << \"Enter number of frames: \";\n    cin >> frames;\n\n\n    cout << \"Enter number of references: \";\n    cin >> n;\n\n\n    vector<int> refs(n);\n    cout << \"Enter reference string: \";\n    for (int i = 0; i < n; i++) cin >> refs[i];\n\n\n    cout << \"\\nMENU:\\n\"\n         << \"1. FIFO\\n\"\n         << \"2. LRU\\n\"\n         << \"3. Optimal\\n\"\n         << \"Enter choice: \";\n\n\n    int ch;\n    cin >> ch;\n\n\n    if (ch == 1)\n        cout << \"FIFO Page Faults = \" << fifoPageFaults(refs, frames) << endl;\n    else if (ch == 2)\n        cout << \"LRU Page Faults = \" << lruPageFaults(refs, frames) << endl;\n    else if (ch == 3)\n        cout << \"Optimal Page Faults = \" << optimalPageFaults(refs, frames) << endl;\n    else\n        cout << \"Invalid choice\\n\";\n\n\n    return 0;\n}\n"
];


const ArticleContent = () => {
  const [isVisible, setIsVisible] = useState(false)
  const contentRef = useRef(null)

  useEffect(() => {
    const observer = new IntersectionObserver(
      (entries) => {
        entries.forEach((entry) => {
          if (entry.isIntersecting) {
            setIsVisible(true)
            observer.unobserve(entry.target)
          }
        })
      },
      {
        threshold: 0.1,
        rootMargin: '50px'
      }
    )

    if (contentRef.current) {
      observer.observe(contentRef.current)
    }

    return () => {
      if (contentRef.current) {
        observer.unobserve(contentRef.current)
      }
    }
  }, [])

  return (
    <section id="article" className="max-w-4xl mx-auto px-4 sm:px-6 lg:px-8 py-12">
      <div ref={contentRef} className="bg-white rounded-lg shadow-md p-8 md:p-12">
        <h2 className="text-3xl font-bold text-gray-900 mb-8 pb-4 border-b border-gray-200">
          Full Article
        </h2>
        <div className="article-content text-gray-800">
          {isVisible && articleContent.map((paragraph, index) => (
            <p key={index} className="mb-4 leading-7 text-base md:text-lg">
              {paragraph}
            </p>
          ))}
        </div>
      </div>
    </section>
  )
}

export default ArticleContent

