import { useState, useEffect, useRef } from 'react'

// Placeholder for Word document content
// Replace this array with the actual content from your Word document
// Each string in the array will become a paragraph
const articleContent = [
'OS LAB',
'3_Write a program to compute the finish time, turnaround time and waiting time for the following algorithms:',
'a) First come First serve',
'b) Shortest Job First (Preemptive and Non-Preemptive)',
'c) Priority (Preemptive and Non-Preemptive)',
'd) Round robin',
'Code: ',
'#include <iostream>',
'#include <algorithm>',
'#include <queue>',
'#include <vector>',
'using namespace std;',
'',
'struct Process {',
'    int pid, at, bt, rt, pr, ft, tat, wt;',
'    bool done = false;',
'};',
'',
'// =================== FCFS ===================',
'void FCFS(vector<Process> p, int n) {',
'    sort(p.begin(), p.end(), [](Process a, Process b){ return a.at < b.at; });',
'',
'    p[0].ft = p[0].at + p[0].bt;',
'    p[0].tat = p[0].ft - p[0].at;',
'    p[0].wt = p[0].tat - p[0].bt;',
'',
'    for (int i = 1; i < n; i++) {',
'        if (p[i].at > p[i - 1].ft)',
'            p[i].ft = p[i].at + p[i].bt;',
'        else',
'            p[i].ft = p[i - 1].ft + p[i].bt;',
'',
'        p[i].tat = p[i].ft - p[i].at;',
'        p[i].wt = p[i].tat - p[i].bt;',
'    }',
'',
'    cout << \"\\nFCFS Scheduling:\\nPID\\tAT\\tBT\\tFT\\tTAT\\tWT\\n\";',
'    for (auto &x : p)',
'        cout << x.pid << \"\\t\" << x.at << \"\\t\" << x.bt << \"\\t\"',
'             << x.ft << \"\\t\" << x.tat << \"\\t\" << x.wt << \"\\n\";',
'}',
'',
'// =================== SJF Non-Preemptive ===================',
'void SJF_NP(vector<Process> p, int n) {',
'    int t = 0, completed = 0;',
'    while (completed < n) {',
'        int idx = -1, mn = 1e9;',
'        for (int i = 0; i < n; i++) {',
'            if (!p[i].done && p[i].at <= t && p[i].bt < mn) {',
'                mn = p[i].bt;',
'                idx = i;',
'            }',
'        }',
'        if (idx == -1) { t++; continue; }',
'        t += p[idx].bt;',
'        p[idx].ft = t;',
'        p[idx].tat = p[idx].ft - p[idx].at;',
'        p[idx].wt = p[idx].tat - p[idx].bt;',
'        p[idx].done = true;',
'        completed++;',
'    }',
'',
'    cout << \"\\nSJF Non-Preemptive:\\nPID\\tAT\\tBT\\tFT\\tTAT\\tWT\\n\";',
'    for (auto &x : p)',
'        cout << x.pid << \"\\t\" << x.at << \"\\t\" << x.bt << \"\\t\"',
'             << x.ft << \"\\t\" << x.tat << \"\\t\" << x.wt << \"\\n\";',
'}',
'',
'// =================== SJF Preemptive (SRTF) ===================',
'void SJF_P(vector<Process> p, int n) {',
'    for (int i = 0; i < n; i++) p[i].rt = p[i].bt;',
'    int t = 0, completed = 0;',
'',
'    while (completed < n) {',
'        int idx = -1, mn = 1e9;',
'        for (int i = 0; i < n; i++) {',
'            if (p[i].at <= t && p[i].rt > 0 && p[i].rt < mn) {',
'                mn = p[i].rt;',
'                idx = i;',
'            }',
'        }',
'        if (idx == -1) { t++; continue; }',
'        p[idx].rt--; t++;',
'        if (p[idx].rt == 0) {',
'            p[idx].ft = t;',
'            p[idx].tat = p[idx].ft - p[idx].at;',
'            p[idx].wt = p[idx].tat - p[idx].bt;',
'            completed++;',
'        }',
'    }',
'',
'    cout << \"\\nSJF Preemptive (SRTF):\\nPID\\tAT\\tBT\\tFT\\tTAT\\tWT\\n\";',
'    for (auto &x : p)',
'        cout << x.pid << \"\\t\" << x.at << \"\\t\" << x.bt << \"\\t\"',
'             << x.ft << \"\\t\" << x.tat << \"\\t\" << x.wt << \"\\n\";',
'}',
'',
'// =================== Priority Non-Preemptive ===================',
'void Priority_NP(vector<Process> p, int n) {',
'    int t = 0, completed = 0;',
'    while (completed < n) {',
'        int idx = -1, best = 1e9;',
'        for (int i = 0; i < n; i++) {',
'            if (!p[i].done && p[i].at <= t && p[i].pr < best) {',
'                best = p[i].pr;',
'                idx = i;',
'            }',
'        }',
'        if (idx == -1) { t++; continue; }',
'        t += p[idx].bt;',
'        p[idx].ft = t;',
'        p[idx].tat = p[idx].ft - p[idx].at;',
'        p[idx].wt = p[idx].tat - p[idx].bt;',
'        p[idx].done = true;',
'        completed++;',
'    }',
'',
'    cout << \"\\nPriority Non-Preemptive:\\nPID\\tAT\\tBT\\tPR\\tFT\\tTAT\\tWT\\n\";',
'    for (auto &x : p)',
'        cout << x.pid << \"\\t\" << x.at << \"\\t\" << x.bt << \"\\t\" << x.pr << \"\\t\"',
'             << x.ft << \"\\t\" << x.tat << \"\\t\" << x.wt << \"\\n\";',
'}',
'',
'// =================== Priority Preemptive ===================',
'void Priority_P(vector<Process> p, int n) {',
'    for (int i = 0; i < n; i++) p[i].rt = p[i].bt;',
'    int t = 0, completed = 0;',
'',
'    while (completed < n) {',
'        int idx = -1, best = 1e9;',
'        for (int i = 0; i < n; i++) {',
'            if (p[i].at <= t && p[i].rt > 0 && p[i].pr < best) {',
'                best = p[i].pr;',
'                idx = i;',
'            }',
'        }',
'        if (idx == -1) { t++; continue; }',
'        p[idx].rt--; t++;',
'        if (p[idx].rt == 0) {',
'            p[idx].ft = t;',
'            p[idx].tat = p[idx].ft - p[idx].at;',
'            p[idx].wt = p[idx].tat - p[idx].bt;',
'            completed++;',
'        }',
'    }',
'',
'    cout << \"\\nPriority Preemptive:\\nPID\\tAT\\tBT\\tPR\\tFT\\tTAT\\tWT\\n\";',
'    for (auto &x : p)',
'        cout << x.pid << \"\\t\" << x.at << \"\\t\" << x.bt << \"\\t\" << x.pr << \"\\t\"',
'             << x.ft << \"\\t\" << x.tat << \"\\t\" << x.wt << \"\\n\";',
'}',
'',
'// =================== Round Robin ===================',
'void RoundRobin(vector<Process> p, int n, int tq) {',
'    for (int i = 0; i < n; i++) p[i].rt = p[i].bt;',
'    queue<int> q;',
'    vector<bool> inQueue(n, false);',
'    int t = 0, completed = 0;',
'',
'    while (completed < n) {',
'        for (int i = 0; i < n; i++)',
'            if (!inQueue[i] && p[i].at <= t && p[i].rt > 0) {',
'                q.push(i); inQueue[i] = true;',
'            }',
'',
'        if (q.empty()) { t++; continue; }',
'',
'        int idx = q.front(); q.pop();',
'        int exec = min(tq, p[idx].rt);',
'        p[idx].rt -= exec;',
'        t += exec;',
'',
'        for (int i = 0; i < n; i++)',
'            if (!inQueue[i] && p[i].at <= t && p[i].rt > 0) {',
'                q.push(i); inQueue[i] = true;',
'            }',
'',
'        if (p[idx].rt > 0)',
'            q.push(idx);',
'        else {',
'            p[idx].ft = t;',
'            p[idx].tat = p[idx].ft - p[idx].at;',
'            p[idx].wt = p[idx].tat - p[idx].bt;',
'            completed++;',
'        }',
'    }',
'',
'    cout << \"\\nRound Robin:\\nPID\\tAT\\tBT\\tFT\\tTAT\\tWT\\n\";',
'    for (auto &x : p)',
'        cout << x.pid << \"\\t\" << x.at << \"\\t\" << x.bt << \"\\t\"',
'             << x.ft << \"\\t\" << x.tat << \"\\t\" << x.wt << \"\\n\";',
'}',
'',
'// =================== MAIN MENU ===================',
'int main() {',
'    int n, choice, tq;',
'    cout << \"Enter number of processes: \";',
'    cin >> n;',
'    vector<Process> p(n);',
'',
'    for (int i = 0; i < n; i++) {',
'        p[i].pid = i + 1;',
'        cout << \"Enter Arrival Time and Burst Time for P\" << p[i].pid << \": \";',
'        cin >> p[i].at >> p[i].bt;',
'        cout << \"Enter Priority for P\" << p[i].pid << \": \";',
'        cin >> p[i].pr;',
'    }',
'',
'    cout << \"\\nChoose Scheduling Algorithm:\\n\";',
'    cout << \"1. FCFS\\n\";',
'    cout << \"2. SJF Non-Preemptive\\n\";',
'    cout << \"3. SJF Preemptive (SRTF)\\n\";',
'    cout << \"4. Priority Non-Preemptive\\n\";',
'    cout << \"5. Priority Preemptive\\n\";',
'    cout << \"6. Round Robin\\n\";',
'    cout << \"Enter choice: \";',
'    cin >> choice;',
'',
'    switch (choice) {',
'        case 1: FCFS(p, n); break;',
'        case 2: SJF_NP(p, n); break;',
'        case 3: SJF_P(p, n); break;',
'        case 4: Priority_NP(p, n); break;',
'        case 5: Priority_P(p, n); break;',
'        case 6: cout << \"Enter Time Quantum: \"; cin >> tq;',
'                RoundRobin(p, n, tq); break;',
'        default: cout << \"Invalid Choice!\\n\";',
'    }',
'    return 0;',
'}',
'',
'',
'4_Write a program to check whether given system is in safe state or not using Banker\u2019s Deadlock Avoidance algorithm.',
'',
'#include <iostream>',
'#include <vector>',
'',
'int main() {',
'    int n, m; // n = number of processes, m = number of resource types',
'',
'    std::cout << \"Enter number of processes: \";',
'    std::cin >> n;',
'',
'    std::cout << \"Enter number of resource types: \";',
'    std::cin >> m;',
'',
'    std::vector<std::vector<int>> alloc(n, std::vector<int>(m));',
'    std::vector<std::vector<int>> maxm(n, std::vector<int>(m));',
'    std::vector<std::vector<int>> need(n, std::vector<int>(m));',
'    std::vector<int> avail(m);',
'    std::vector<int> finish(n, 0);',
'    std::vector<int> safeSeq(n);',
'',
'    // Input Allocation Matrix',
'    std::cout << \"Enter Allocation Matrix (\" << n << \" x \" << m << \"):\\n\";',
'    for (int i = 0; i < n; i++) {',
'        for (int j = 0; j < m; j++) {',
'            std::cin >> alloc[i][j];',
'        }',
'    }',
'',
'    // Input Max Matrix',
'    std::cout << \"Enter Max Matrix (\" << n << \" x \" << m << \"):\\n\";',
'    for (int i = 0; i < n; i++) {',
'        for (int j = 0; j < m; j++) {',
'            std::cin >> maxm[i][j];',
'        }',
'    }',
'',
'    // Input Available resources',
'    std::cout << \"Enter Available resources (\" << m << \" values):\\n\";',
'    for (int j = 0; j < m; j++) {',
'        std::cin >> avail[j];',
'    }',
'',
'    // Calculate Need matrix: need = max - alloc',
'    for (int i = 0; i < n; i++) {',
'        for (int j = 0; j < m; j++) {',
'            need[i][j] = maxm[i][j] - alloc[i][j];',
'        }',
'    }',
'',
'    int count = 0; // number of processes in safe sequence',
'',
'    // Safety Algorithm',
'    while (count < n) {',
'        bool found = false;',
'',
'        for (int i = 0; i < n; i++) {',
'            if (finish[i] == 0) {',
'                bool canAllocate = true;',
'',
'                // Check if need[i] <= avail for all resources',
'                for (int j = 0; j < m; j++) {',
'                    if (need[i][j] > avail[j]) {',
'                        canAllocate = false;',
'                        break;',
'                    }',
'                }',
'',
'                // If process i can be allocated',
'                if (canAllocate) {',
'                    for (int k = 0; k < m; k++) {',
'                        avail[k] += alloc[i][k];',
'                    }',
'',
'                    safeSeq[count++] = i;',
'                    finish[i] = 1;',
'                    found = true;',
'                }',
'            }',
'        }',
'',
'        // If no process could be allocated in this pass, system is not safe',
'        if (!found) {',
'            std::cout << \"\\nSystem is NOT in a safe state (Deadlock possible).\\n\";',
'            return 0;',
'        }',
'    }',
'',
'    // If all processes are finished, system is safe',
'    std::cout << \"\\nSystem is in a SAFE state.\\nSafe sequence: \";',
'    for (int i = 0; i < n; i++) {',
'        std::cout << \"P\" << safeSeq[i] << \" \";',
'    }',
'    std::cout << \"\\n\";',
'',
'    return 0;',
'}',
'',
'',
'',
'5_Implementation of Classical problems using Threads and Mutex.',
'',
'#include <iostream>',
'#include <thread>',
'#include <mutex>',
'#include <condition_variable>',
'#include <vector>',
'#include <chrono>',
'#include <atomic>',
'',
'/* ---------- PRODUCER\u2013CONSUMER (BOUNDED BUFFER) ---------- */',
'',
'#define BUFFER_SIZE 5',
'#define PC_ITERATIONS 5',
'',
'int buffer_pc[BUFFER_SIZE];',
'int count_pc = 0;',
'int in_pc = 0, out_pc = 0;',
'',
'std::mutex pc_mutex;',
'std::condition_variable pc_not_full;',
'std::condition_variable pc_not_empty;',
'',
'void producer() {',
'    int item = 1;',
'    for (int i = 0; i < PC_ITERATIONS; i++) {',
'        std::unique_lock<std::mutex> lock(pc_mutex);',
'',
'        pc_not_full.wait(lock, [] { return count_pc < BUFFER_SIZE; });',
'',
'        buffer_pc[in_pc] = item;',
'        std::cout << \"[Producer] produced: \" << item << \"\\n\";',
'        in_pc = (in_pc + 1) % BUFFER_SIZE;',
'        count_pc++;',
'        item++;',
'',
'        pc_not_empty.notify_one();',
'        lock.unlock();',
'',
'        std::this_thread::sleep_for(std::chrono::seconds(1));',
'    }',
'}',
'',
'void consumer() {',
'    for (int i = 0; i < PC_ITERATIONS; i++) {',
'        std::unique_lock<std::mutex> lock(pc_mutex);',
'',
'        pc_not_empty.wait(lock, [] { return count_pc > 0; });',
'',
'        int item = buffer_pc[out_pc];',
'        std::cout << \"[Consumer] consumed: \" << item << \"\\n\";',
'        out_pc = (out_pc + 1) % BUFFER_SIZE;',
'        count_pc--;',
'',
'        pc_not_full.notify_one();',
'        lock.unlock();',
'',
'        std::this_thread::sleep_for(std::chrono::seconds(1));',
'    }',
'}',
'',
'void run_producer_consumer() {',
'    count_pc = 0;',
'    in_pc = out_pc = 0;',
'',
'    std::cout << \"\\n--- Producer\u2013Consumer Simulation ---\\n\";',
'',
'    std::thread prod(producer);',
'    std::thread cons(consumer);',
'',
'    prod.join();',
'    cons.join();',
'',
'    std::cout << \"--- Producer\u2013Consumer Finished ---\\n\\n\";',
'}',
'',
'/* ---------- DINING PHILOSOPHERS ---------- */',
'',
'#define NPHIL 5',
'#define EAT_TIMES 3',
'',
'std::mutex forks[NPHIL];',
'',
'void philosopher(int id) {',
'    for (int i = 0; i < EAT_TIMES; i++) {',
'        std::cout << \"Philosopher \" << id << \" is thinking\\n\";',
'        std::this_thread::sleep_for(std::chrono::seconds(1));',
'',
'        if (id == NPHIL - 1) {',
'            // Last philosopher picks up right then left to avoid deadlock',
'            forks[(id + 1) % NPHIL].lock();',
'            forks[id].lock();',
'        } else {',
'            forks[id].lock();',
'            forks[(id + 1) % NPHIL].lock();',
'        }',
'',
'        std::cout << \"Philosopher \" << id << \" is eating\\n\";',
'        std::this_thread::sleep_for(std::chrono::seconds(1));',
'',
'        forks[id].unlock();',
'        forks[(id + 1) % NPHIL].unlock();',
'    }',
'    std::cout << \"Philosopher \" << id << \" is done.\\n\";',
'}',
'',
'void run_dining_philosophers() {',
'    std::cout << \"\\n--- Dining Philosophers Simulation ---\\n\";',
'',
'    std::vector<std::thread> threads;',
'',
'    for (int i = 0; i < NPHIL; i++) {',
'        threads.emplace_back(philosopher, i);',
'    }',
'',
'    for (auto& t : threads) {',
'        t.join();',
'    }',
'',
'    std::cout << \"--- Dining Philosophers Finished ---\\n\\n\";',
'}',
'',
'/* ---------- READERS\u2013WRITERS (FIRST PROBLEM) ---------- */',
'',
'int read_count = 0;',
'int shared_data = 0;',
'',
'std::mutex rw_mutex;        // for protecting read_count',
'std::mutex rw_write_lock;   // for writers (and first/last reader)',
'',
'#define READERS 3',
'#define WRITERS 2',
'#define RW_ITER 3',
'',
'void reader(int id) {',
'    for (int i = 0; i < RW_ITER; i++) {',
'        // Entry section',
'        {',
'            std::lock_guard<std::mutex> lock(rw_mutex);',
'            read_count++;',
'            if (read_count == 1) {',
'                rw_write_lock.lock();',
'            }',
'        }',
'',
'        // Critical section',
'        std::cout << \"[Reader \" << id << \"] reads data = \" << shared_data << \"\\n\";',
'        std::this_thread::sleep_for(std::chrono::seconds(1));',
'',
'        // Exit section',
'        {',
'            std::lock_guard<std::mutex> lock(rw_mutex);',
'            read_count--;',
'            if (read_count == 0) {',
'                rw_write_lock.unlock();',
'            }',
'        }',
'',
'        std::this_thread::sleep_for(std::chrono::seconds(1));',
'    }',
'}',
'',
'void writer(int id) {',
'    for (int i = 0; i < RW_ITER; i++) {',
'        rw_write_lock.lock();',
'',
'        shared_data++;',
'        std::cout << \"[Writer \" << id << \"] writes data = \" << shared_data << \"\\n\";',
'        std::this_thread::sleep_for(std::chrono::seconds(1));',
'',
'        rw_write_lock.unlock();',
'',
'        std::this_thread::sleep_for(std::chrono::seconds(2));',
'    }',
'}',
'',
'void run_readers_writers() {',
'    std::cout << \"\\n--- Readers\u2013Writers Simulation ---\\n\";',
'',
'    read_count = 0;',
'    shared_data = 0;',
'',
'    std::vector<std::thread> rthreads;',
'    std::vector<std::thread> wthreads;',
'',
'    for (int i = 0; i < READERS; i++) {',
'        rthreads.emplace_back(reader, i + 1);',
'    }',
'',
'    for (int i = 0; i < WRITERS; i++) {',
'        wthreads.emplace_back(writer, i + 1);',
'    }',
'',
'    for (auto& t : rthreads) {',
'        t.join();',
'    }',
'    for (auto& t : wthreads) {',
'        t.join();',
'    }',
'',
'    std::cout << \"--- Readers\u2013Writers Finished ---\\n\\n\";',
'}',
'',
'/* ---------- MAIN MENU ---------- */',
'',
'int main() {',
'    int choice;',
'',
'    while (true) {',
'        std::cout << \"==== Classical Problems using C++ Threads & Mutex ====\\n\";',
'        std::cout << \"1. Producer\u2013Consumer Problem\\n\";',
'        std::cout << \"2. Dining Philosophers Problem\\n\";',
'        std::cout << \"3. Readers\u2013Writers Problem\\n\";',
'        std::cout << \"4. Exit\\n\";',
'        std::cout << \"Enter your choice: \";',
'',
'        if (!(std::cin >> choice)) {',
'            std::cout << \"Invalid input. Exiting.\\n\";',
'            break;',
'        }',
'',
'        switch (choice) {',
'            case 1:',
'                run_producer_consumer();',
'                break;',
'            case 2:',
'                run_dining_philosophers();',
'                break;',
'            case 3:',
'                run_readers_writers();',
'                break;',
'            case 4:',
'                std::cout << \"Exiting...\\n\";',
'                return 0;',
'            default:',
'                std::cout << \"Invalid choice. Try again.\\n\\n\";',
'        }',
'    }',
'',
'    return 0;',
'}',
'',
'6_Implementation of Classical problems using Threads and Semaphore.',
'',
'#include <iostream>',
'#include <cstdlib>',
'#include <pthread.h>',
'#include <unistd.h>',
'#include <semaphore.h>',
'',
'/* ========== 1. PRODUCER\u2013CONSUMER USING SEMAPHORES ========== */',
'',
'#define BUFFER_SIZE 5',
'#define PC_ITERATIONS 5',
'',
'int buffer[BUFFER_SIZE];',
'int in_pc = 0, out_pc = 0;',
'',
'sem_t empty;      // counts empty slots',
'sem_t full;       // counts full slots',
'sem_t pc_mutex;   // binary semaphore for mutual exclusion',
'',
'void* producer_sema(void* arg) {',
'    int item = 1;',
'    for (int i = 0; i < PC_ITERATIONS; i++) {',
'        sem_wait(&empty);         // wait for empty slot',
'        sem_wait(&pc_mutex);      // lock buffer',
'',
'        buffer[in_pc] = item;',
'        std::cout << \"[Producer] produced: \" << item << std::endl;',
'        in_pc = (in_pc + 1) % BUFFER_SIZE;',
'        item++;',
'',
'        sem_post(&pc_mutex);      // unlock buffer',
'        sem_post(&full);          // signal item available',
'',
'        sleep(1);',
'    }',
'    return nullptr;',
'}',
'',
'void* consumer_sema(void* arg) {',
'    for (int i = 0; i < PC_ITERATIONS; i++) {',
'        sem_wait(&full);          // wait for available item',
'        sem_wait(&pc_mutex);      // lock buffer',
'',
'        int item = buffer[out_pc];',
'        std::cout << \"[Consumer] consumed: \" << item << std::endl;',
'        out_pc = (out_pc + 1) % BUFFER_SIZE;',
'',
'        sem_post(&pc_mutex);      // unlock buffer',
'        sem_post(&empty);         // signal empty slot',
'',
'        sleep(1);',
'    }',
'    return nullptr;',
'}',
'',
'void run_producer_consumer_sema() {',
'    pthread_t prod, cons;',
'',
'    in_pc = out_pc = 0;',
'',
'    sem_init(&empty, 0, BUFFER_SIZE);',
'    sem_init(&full, 0, 0);',
'    sem_init(&pc_mutex, 0, 1);',
'',
'    std::cout << \"\\n--- Producer\u2013Consumer using Semaphores ---\" << std::endl;',
'',
'    pthread_create(&prod, nullptr, producer_sema, nullptr);',
'    pthread_create(&cons, nullptr, consumer_sema, nullptr);',
'',
'    pthread_join(prod, nullptr);',
'    pthread_join(cons, nullptr);',
'',
'    sem_destroy(&empty);',
'    sem_destroy(&full);',
'    sem_destroy(&pc_mutex);',
'',
'    std::cout << \"--- Producer\u2013Consumer Finished ---\\n\" << std::endl;',
'}',
'',
'/* ========== 2. DINING PHILOSOPHERS USING SEMAPHORES ========== */',
'',
'#define NPHIL 5',
'#define EAT_TIMES 3',
'',
'sem_t forks_sema[NPHIL];',
'',
'void* philosopher_sema(void* arg) {',
'    int id = *static_cast<int*>(arg);',
'',
'    for (int i = 0; i < EAT_TIMES; i++) {',
'        std::cout << \"Philosopher \" << id << \" is thinking\" << std::endl;',
'        sleep(1);',
'',
'        int left = id;',
'        int right = (id + 1) % NPHIL;',
'',
'        // To reduce deadlock chance, let last philosopher pick right first',
'        if (id == NPHIL - 1) {',
'            sem_wait(&forks_sema[right]);',
'            sem_wait(&forks_sema[left]);',
'        } else {',
'            sem_wait(&forks_sema[left]);',
'            sem_wait(&forks_sema[right]);',
'        }',
'',
'        std::cout << \"Philosopher \" << id << \" is eating\" << std::endl;',
'        sleep(1);',
'',
'        sem_post(&forks_sema[left]);',
'        sem_post(&forks_sema[right]);',
'    }',
'    std::cout << \"Philosopher \" << id << \" is done.\" << std::endl;',
'    return nullptr;',
'}',
'',
'void run_dining_philosophers_sema() {',
'    pthread_t tid[NPHIL];',
'    int ids[NPHIL];',
'',
'    std::cout << \"\\n--- Dining Philosophers using Semaphores ---\" << std::endl;',
'',
'    for (int i = 0; i < NPHIL; i++) {',
'        sem_init(&forks_sema[i], 0, 1); // each fork available (1)',
'    }',
'',
'    for (int i = 0; i < NPHIL; i++) {',
'        ids[i] = i;',
'        pthread_create(&tid[i], nullptr, philosopher_sema, &ids[i]);',
'    }',
'',
'    for (int i = 0; i < NPHIL; i++) {',
'        pthread_join(tid[i], nullptr);',
'    }',
'',
'    for (int i = 0; i < NPHIL; i++) {',
'        sem_destroy(&forks_sema[i]);',
'    }',
'',
'    std::cout << \"--- Dining Philosophers Finished ---\\n\" << std::endl;',
'}',
'',
'/* ========== 3. READERS\u2013WRITERS USING SEMAPHORES (1st problem) ========== */',
'',
'int read_count = 0;',
'int shared_data = 0;',
'',
'sem_t rw_mutex;     // protects read_count',
'sem_t rw_wrt;       // ensures mutual exclusion for writers',
'',
'#define READERS 3',
'#define WRITERS 2',
'#define RW_ITER 3',
'',
'void* reader_sema(void* arg) {',
'    int id = *static_cast<int*>(arg);',
'',
'    for (int i = 0; i < RW_ITER; i++) {',
'        sem_wait(&rw_mutex);',
'        read_count++;',
'        if (read_count == 1) {',
'            sem_wait(&rw_wrt);    // first reader locks writers',
'        }',
'        sem_post(&rw_mutex);',
'',
'        std::cout << \"[Reader \" << id << \"] reads data = \" << shared_data << std::endl;',
'        sleep(1);',
'',
'        sem_wait(&rw_mutex);',
'        read_count--;',
'        if (read_count == 0) {',
'            sem_post(&rw_wrt);    // last reader unlocks writers',
'        }',
'        sem_post(&rw_mutex);',
'',
'        sleep(1);',
'    }',
'    return nullptr;',
'}',
'',
'void* writer_sema(void* arg) {',
'    int id = *static_cast<int*>(arg);',
'',
'    for (int i = 0; i < RW_ITER; i++) {',
'        sem_wait(&rw_wrt);',
'',
'        shared_data++;',
'        std::cout << \"[Writer \" << id << \"] writes data = \" << shared_data << std::endl;',
'        sleep(1);',
'',
'        sem_post(&rw_wrt);',
'',
'        sleep(2);',
'    }',
'    return nullptr;',
'}',
'',
'void run_readers_writers_sema() {',
'    pthread_t rtid[READERS], wtid[WRITERS];',
'    int rids[READERS], wids[WRITERS];',
'',
'    read_count = 0;',
'    shared_data = 0;',
'',
'    sem_init(&rw_mutex, 0, 1);',
'    sem_init(&rw_wrt, 0, 1);',
'',
'    std::cout << \"\\n--- Readers\u2013Writers using Semaphores ---\" << std::endl;',
'',
'    for (int i = 0; i < READERS; i++) {',
'        rids[i] = i + 1;',
'        pthread_create(&rtid[i], nullptr, reader_sema, &rids[i]);',
'    }',
'',
'    for (int i = 0; i < WRITERS; i++) {',
'        wids[i] = i + 1;',
'        pthread_create(&wtid[i], nullptr, writer_sema, &wids[i]);',
'    }',
'',
'    for (int i = 0; i < READERS; i++) {',
'        pthread_join(rtid[i], nullptr);',
'    }',
'    for (int i = 0; i < WRITERS; i++) {',
'        pthread_join(wtid[i], nullptr);',
'    }',
'',
'    sem_destroy(&rw_mutex);',
'    sem_destroy(&rw_wrt);',
'',
'    std::cout << \"--- Readers\u2013Writers Finished ---\\n\" << std::endl;',
'}',
'',
'/* ========== MAIN MENU ========== */',
'',
'int main() {',
'    int choice;',
'',
'    while (true) {',
'        std::cout << \"==== Classical Problems using Threads & Semaphores ====\\n\";',
'        std::cout << \"1. Producer\u2013Consumer Problem\\n\";',
'        std::cout << \"2. Dining Philosophers Problem\\n\";',
'        std::cout << \"3. Readers\u2013Writers Problem\\n\";',
'        std::cout << \"4. Exit\\n\";',
'        std::cout << \"Enter your choice: \";',
'',
'        if (!(std::cin >> choice)) {',
'            std::cout << \"Invalid input. Exiting.\\n\";',
'            break;',
'        }',
'',
'        switch (choice) {',
'            case 1:',
'                run_producer_consumer_sema();',
'                break;',
'            case 2:',
'                run_dining_philosophers_sema();',
'                break;',
'            case 3:',
'                run_readers_writers_sema();',
'                break;',
'            case 4:',
'                std::cout << \"Exiting...\\n\";',
'                return 0;',
'            default:',
'                std::cout << \"Invalid choice. Try again.\\n\\n\";',
'        }',
'    }',
'',
'    return 0;',
'}',
'',
'',
'7_Write a program to calculate the number of page faults for a reference string for the following page replacement algorithms: a) FIFO b) LRU c) Optimal',
'',
'Code:',
'#include <bits/stdc++.h>',
'using namespace std;',
'',
'int fifoPageFaults(vector<int>& refs, int frames) {',
'    queue<int> q;',
'    unordered_set<int> s;',
'    int faults = 0;',
'',
'    for (int p : refs) {',
'        if (s.find(p) == s.end()) {',
'            faults++;',
'            if (q.size() == frames) {',
'                int old = q.front(); q.pop();',
'                s.erase(old);',
'            }',
'            q.push(p);',
'            s.insert(p);',
'        }',
'    }',
'    return faults;',
'}',
'',
'int lruPageFaults(vector<int>& refs, int frames) {',
'    list<int> recent;',
'    unordered_map<int, list<int>::iterator> mp;',
'    int faults = 0;',
'',
'    for (int p : refs) {',
'        if (mp.find(p) == mp.end()) {',
'            faults++;',
'            if (recent.size() == frames) {',
'                int lru = recent.front();',
'                recent.pop_front();',
'                mp.erase(lru);',
'            }',
'            recent.push_back(p);',
'            mp[p] = --recent.end();',
'        } else {',
'            recent.erase(mp[p]);',
'            recent.push_back(p);',
'            mp[p] = --recent.end();',
'        }',
'    }',
'    return faults;',
'}',
'',
'int optimalPageFaults(vector<int>& refs, int frames) {',
'    vector<int> fr;',
'    int faults = 0;',
'    int n = refs.size();',
'',
'    for (int i = 0; i < n; i++) {',
'        int p = refs[i];',
'        bool hit = false;',
'',
'        for (int x : fr)',
'            if (x == p) hit = true;',
'',
'        if (hit) continue;',
'',
'        faults++;',
'',
'        if (fr.size() < frames) {',
'            fr.push_back(p);',
'            continue;',
'        }',
'',
'        int idx = -1, farthest = -1;',
'',
'        for (int j = 0; j < fr.size(); j++) {',
'            int page = fr[j];',
'            int k;',
'            for (k = i + 1; k < n; k++)',
'                if (refs[k] == page) break;',
'',
'            if (k == n) {',
'                idx = j;',
'                break;',
'            }',
'',
'            if (k > farthest) {',
'                farthest = k;',
'                idx = j;',
'            }',
'        }',
'',
'        fr[idx] = p;',
'    }',
'    return faults;',
'}',
'',
'int main() {',
'    int frames, n;',
'',
'    cout << \"Enter number of frames: \";',
'    cin >> frames;',
'',
'    cout << \"Enter number of references: \";',
'    cin >> n;',
'',
'    vector<int> refs(n);',
'    cout << \"Enter reference string: \";',
'    for (int i = 0; i < n; i++) cin >> refs[i];',
'',
'    cout << \"\\nMENU:\\n\"',
'         << \"1. FIFO\\n\"',
'         << \"2. LRU\\n\"',
'         << \"3. Optimal\\n\"',
'         << \"Enter choice: \";',
'',
'    int ch;',
'    cin >> ch;',
'',
'    if (ch == 1)',
'        cout << \"FIFO Page Faults = \" << fifoPageFaults(refs, frames) << endl;',
'    else if (ch == 2)',
'        cout << \"LRU Page Faults = \" << lruPageFaults(refs, frames) << endl;',
'    else if (ch == 3)',
'        cout << \"Optimal Page Faults = \" << optimalPageFaults(refs, frames) << endl;',
'    else',
'        cout << \"Invalid choice\\n\";',
'',
'    return 0;',
'}',
];




const ArticleContent = () => {
  const [isVisible, setIsVisible] = useState(false)
  const contentRef = useRef(null)

  useEffect(() => {
    const observer = new IntersectionObserver(
      (entries) => {
        entries.forEach((entry) => {
          if (entry.isIntersecting) {
            setIsVisible(true)
            observer.unobserve(entry.target)
          }
        })
      },
      {
        threshold: 0.1,
        rootMargin: '50px'
      }
    )

    if (contentRef.current) {
      observer.observe(contentRef.current)
    }

    return () => {
      if (contentRef.current) {
        observer.unobserve(contentRef.current)
      }
    }
  }, [])

  return (
    <section id="article" className="max-w-4xl mx-auto px-4 sm:px-6 lg:px-8 py-12">
      <div ref={contentRef} className="bg-white rounded-lg shadow-md p-8 md:p-12">
        <h2 className="text-3xl font-bold text-gray-900 mb-8 pb-4 border-b border-gray-200">
          Full Article
        </h2>
        <div className="article-content text-gray-800">
          {isVisible && articleContent.map((paragraph, index) => (
            <p key={index} className="mb-4 leading-7 text-base md:text-lg">
              {paragraph}
            </p>
          ))}
        </div>
      </div>
    </section>
  )
}

export default ArticleContent

